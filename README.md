# Fundamental algorithms
Shitcode from my lab's <3

## Задания к работе №6 по фундаментальным алгоритмам.

0. Опишите абстрактный класс TeX_convertible, содержащий единственную чистую виртуальную функцию с прототипом std::string convert() const;, задачей которой является преобразование вызывающего объекта, тип которого наследует TeX_convertible, в строку с кодом на TeX, который при компиляции порождает математическую форму записи этого объекта.

1. Разработайте класс квадратной матрицы, наследующий класс TeX_convertible. Класс должен содержать указатель на место в памяти, где располагаются элементы матрицы (вещественного типа данных) и её размерность (целое неотрицательное число). Для класса реализуйте необходимое число конструкторов (при этом хотя бы один из них должен принимать аргументы по умолчанию); перегрузите конструктор копирования; деструктор; оператор присваивания; арифметические операторы для сложения матриц, вычитания матриц, умножения матриц, умножения матрицы на число и числа на матрицу; операторы сравнения матриц на предмет полного равенства (epsilon принять равным 1e-6); индексатор для взятия значения из матрицы по индексам строки/столбца (отсчёт с 0); операторы вставки в поток и выгрузки из потока. Реализуйте дружественные методы вычисления определителя, нахождения обратной матрицы, нахождения транспонированной матрицы, вычисление следа матрицы и матричной экспоненты. При невозможности выполнения операции, должна быть сгенерирована исключительная ситуация (для каждого типа ошибки - свой тип исключительной ситуации), которая должна быть перехвачена и обработана в вызывающем коде. Продемонстрируйте работу с вашим классом: на вход программе подаётся файл, содержащий выражения с матрицами (каждое из выражений содержит одну из операций: сложение / вычитание / умножение матриц, умножение матрицы на число, умножение числа на матрицу, сравнение матриц (==, !=); нахождение определителя матрицы; нахождение обратной матрицы; нахождение транспонированной матрицы; нахождение следа матрицы; нахождение матричной экспоненты; формат представления данных в файле определите самостоятельно). Необходимо вычислить значения всех выражений и сгенерировать TeX-файл (выражения, при вычислении которых была сгенерирована исключительная ситуация, в выходной файл выписываться не должны), где каждое выражение будет иметь вид <исходное выражение> = <результат вычисления выражения>. (optional) После генерации TeX-файла необходимо запустить его компиляцию и получить на выходе pdf-файл. Замечания. Арифметические операции необходимо реализовать с помощью соответствующих операции присваивания: например, операция + должна быть реализована с помощью операции +=. Необходимо продемонстрировать передачу аргументов в функции по значению и по ссылке; возврат объекта из функции.

2. Реализовать immutable-класс монома от нескольких переменных, наследующий класс TeX_convertible. Класс должен содержать набор уникальных однобуквенных имён переменных, соответствующие именам переменных степени (целое неотрицательное число) и коэффициент (целое число). В классе монома должны быть определены и реализованы следующие сущности:<br/>
● Конструкторы (обязателен конструктор, принимающий на вход строковое представление монома (типа char*); также обязателен перегруженный конструктор копий);<br/>
● Перегруженный деструктор;<br/>
● Перегруженный оператор присваивания;<br/>
● Перегруженные операторы для арифметических операций между мономами: +, +=, -, -=, *, *=;<br/>
● Перегруженные операторы для взятия частной производной монома: /, /= (параметр типа char);<br/>
● Перегруженные операторы для сравнения мономов на предмет полного равенства: ==, !=;<br/>
● Перегруженные операторы вставки в поток и выгрузки из потока для корректного вывода/ввода монома.<br/>
На основе реализованного класса монома необходимо реализовать класс полинома от нескольких переменных (также наследующий класс TeX_convertible). Класс полинома должен представлять собой контейнер мономов на базе двусвязного списка; в произвольный момент времени в полиноме не должны присутствовать мономы, равные без учёта коэффициентов, а также мономы с коэффициентом, равным нулю. В классе полинома необходимо реализовать:<br/>
● Конструкторы (обязателен конструктор, принимающий на вход строковое представление полинома (типа char*); также обязателен перегруженный конструктор копий);<br/>
● Перегруженный деструктор;<br/>
● Перегруженный оператор присваивания;<br/>
● Перегруженные операторы для арифметических операций между полиномами: +, +=, -, -=, *, *=;<br/>
● Перегруженные операторы для взятия частной производной полинома: /, /= (параметр типа char);<br/>
● Перегруженные операторы для взятия смешанной (по нескольким переменным) производной полинома: /, /= (параметр типа char* - строка с именами переменных);<br/>
● Перегруженные операторы для сравнения полиномов: ==, !=;<br/>
● Перегруженные операторы вставки в поток и выгрузки из потока для корректного ввода/вывода полинома;<br/>
● Дружественный метод для проверки полинома на однородность;<br/>
● Дружественный метод для проверки полинома на гармоничность.<br/>
Для демонстрации работы класса полинома реализуйте возможность обработки входного файла, содержащего выражения с полиномами (каждое выражение содержит одну из операций: сложение/вычитание/умножение полиномов; нахождение смешанной производной по строке с именами переменных; сравнение полиномов (==, !=); проверка полинома на однородность; проверка полинома на гармоничность; формат представления данных в файле определите самостоятельно). Необходимо вычислить значения всех выражений и сгенерировать TeX-файл, где каждое выражение будет иметь вид <исходное выражение> = <результат вычисления выражения>. (optional) После генерации TeX-файла необходимо запустить его компиляцию и получить на выходе pdf-файл. Замечания. Арифметические операторы необходимо реализовать с помощью соответствующих арифметических операций с присваиванием (например, оператор + должен быть реализован с помощью оператора +=). Продемонстрировать передачу аргументов в функции по значению и по ссылке.

## Задания к работе №7 по фундаментальным алгоритмам.

0. Опишите абстрактный шаблонный класс binary_tree<T>, представляющий собой абстракцию дерева поиска (тип элементов указывается в единственном параметре шаблона). Класс должен содержать три чистых виртуальных функции: добавления элемента в дерево, удаления элемента из дерева, поиска элемента в дереве по значению. Конструктор класса должен принимать в качестве параметра шаблонный компаратор (правило вычисления отношения порядка между данными в узлах дерева), реализованный в виде объекта стратегии (см. паттерн “Стратегия”).
  
1. На основе класса из задания 1 реализуйте шаблонные классы красно-чёрного дерева и АВЛ-дерева. Сгенерируйте псевдослучайные выборки данных и на их основе проведите сравнительный анализ времени работы и количества операций поворотов в алгоритмах вставки / удаления / поиска для красно-чёрного дерева и АВЛ-дерева.<br/>
2. На основе классов из заданий 1 и 2 реализуйте шаблонный класс relation<T>, содержащий в себе односвязный список данных типа T, а также список индексов типа binary_tree<T> (каждое дерево должно быть построено поверх данных, хранящихся в односвязном списке; компараторы могут быть различны). Предоставьте функционал добавления и удаления данных (с сохранением корректности индексов), поиска данных по значению, а также добавления и удаления индексов (в виде реализованных классов из задания 2).
3. Продемонстрируйте работу класса из задания 3 на примере размещения в объекте данных из файла, каждая строка которого имеет следующий формат: <datetime> <username>: <message> Перед добавлением данных объект должен содержать единственный индекс по полю datetime структуры. После добавления данных необходимо добавить в объект индексы, описанные ниже, и продемонстрировать поиск данных посредством добавленных индексов:<br/>
● по полю username (лексографическое сравнение строк с учётом регистра);<br/>
● по полю message (лексографическое сравнение строк без учёта регистра);<br/>
● первично по полю datetime, вторично по полю username (лексографическое сравнение строк без учёта регистра).
  
4. Продемонстрируйте работу класса из задания 3 на примере размещения в объекте данных из файла, имеющих следующий формат:<br/>
<Фамилия> <Имя> <Отчество><br/>
{<br/>
<Договор #id> нач. <дата начала> кон. <дата окончания> <Стоимость><br/>
<Договор #id> нач. <дата начала> кон. нв <Стоимость><br/>
...<br/>
}<br/>
Перед добавлением данных объект не должен содержать индексов. После добавления данных необходимо добавить и продемонстрировать работу следующих индексов (целевыми данными для индексирования является информация о договорах):<br/>
● первично по ФИО владельца, вторично по id договора;<br/>
● по длительности договора;<br/>
● по стоимости договора.<br/>
  
## Задания к работе №9 по фундаментальным алгоритмам.
  
1. Реализовать класс, предоставляющий функционал логгирования. При построении объекта логгера посредством паттерна “строитель” должна быть произведена настройка потоков вывода (streams) и их размещение в односвязном списке с применением паттерна “цепочка обязанностей”. В качестве имени потока можно указать “stdout” для логгирования в консоль, либо путь к текстовому файлу для логгирования в файл; также для каждого потока вывода можно указать один из уровней “жёсткости” (severity; от наименее жёсткого к наиболее жёсткому: trace, debug, information, warning, error, fatal), означающий, что в этот поток вывода необходимо писать логи с severity не ниже настроенного. Объект логгера должен содержать единственный метод, позволяющий залоггировать строку с указанным уровнем жёсткости (по умолчанию information) во все связанные с ним потоки вывода через прохождение запроса по цепочке. Формат лога: [datetime][severity]: log. Продемонстрируйте работу одновременно двух логгеров(дескрипторы файлов могут быть открыты одновременно для нескольких логгеров): один должен быть настроен в коде на C++, а настройки потоков вывода второго должны быть считаны (с проверкой корректности) из конфигурационного файла в формате .json. При уничтожении объекта логгера, необходимо закрыть все дескрипторы файлов, не использующиеся другими объектами логгеров.
  
## Задание к курсовой работе по фундаментальным алгоритмам.
22. Разработайте приложение для обработки данных переписи населения. Придумайте форму опроса (или найдите готовую в сети). Основным требованием является достаточный объем вопросов (не менее 20), на которые подразумеваются различные виды ответа: в виде числа, с единичным или множественным выбором из предложенных вариантов, либо в виде развернутого текста. Ваше приложение должно обеспечить возможность хранения и обработки результатов опроса. Количество хранимых заполненных форм достаточно велико (> 500’000 шт.). Функционал приложения должен обеспечить возможность поиска форм по различным критериям (минимум 5 различных критериев), статистическую обработку результатов с подсчетом абсолютных и относительных частот для каждого пункта, который могли выбрать участники опроса. Реализуйте возможность добавления результата опроса, удаления результата опроса. Для демонстрации работы реализуйте генератор ответов, выдающий случайным образом заполненные формы опроса (генерация должна быть реализована посредством паттерна “фабричный метод”). Реализуйте функционал обработки данных таким образом, чтобы тип коллекции, в которой будут храниться ваши данные, являлся параметром. Продемонстрируйте обработку данных с использованием std::list и собственной реализации АВЛ-дерева (с компаратором-стратегией).

## Chess_Eight_Queens
Реализуйте приложение, решающее задачу о 8 ферзях (в результате решения необходимо вернуть (формат хранения позиции определите самостоятельно) все возможные конфигурации расстановки ферзей с учëтом поворотов/флипа игровой доски). Для решения задачи опишите интерфейс, предоставляющий метод решения задачи, в подклассах реализуйте этот интерфейс для
1) рекурсивного поиска решений;
2) итеративного поиска решений.<br/>
  
Сравните реализованные методы на предмет времени работы.
